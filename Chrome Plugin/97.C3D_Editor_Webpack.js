"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[97],{4097:(t,n,e)=>{e.d(n,{USDZExporter:()=>i});var o=e(9451),r=e(7680),a=e(4655);class i{parse(t,n,e,o){this.parseAsync(t,o).then(n).catch(e)}async parseAsync(t,n={}){n=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},includeAnchoringProperties:!0,quickLookCompatible:!1,maxTextureSize:1024},n);const e={},o="model.usda";e[o]=null;let i='#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n';i+=function(t){return`def Xform "Root"\n{\n\tdef Scope "Scenes" (\n\t\tkind = "sceneLibrary"\n\t)\n\t{\n\t\tdef Xform "Scene" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = "Scene"\n\t\t\t}\n\t\t\tsceneName = "Scene"\n\t\t)\n\t\t{${!0===t.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${t.ar.anchoring.type}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\t`:""}\n`}(n);const c={},d={};t.traverseVisible((t=>{if(t.isMesh){const n=t.geometry,o=t.material;if(o.isMeshStandardMaterial){const a="geometries/Geometry_"+n.id+".usda";if(!(a in e)){const t=function(t){const n=function(t){const n=t.attributes,e=n.position.count;return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(t){const n=null!==t.index?t.index.count:t.attributes.position.count;return Array(n/3).fill(3).join(", ")}(t)}]\n\t\tint[] faceVertexIndices = [${function(t){const n=t.index,e=[];if(null!==n)for(let t=0;t<n.count;t++)e.push(n.getX(t));else{const n=t.attributes.position.count;for(let t=0;t<n;t++)e.push(t)}return e.join(", ")}(t)}]\n\t\tnormal3f[] normals = [${p(n.normal,e)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${p(n.position,e)}]\n${function(t){let n="";for(let e=0;e<4;e++){const o=e>0?e:"",r=t["uv"+o];void 0!==r&&(n+=`\n\t\ttexCoord2f[] primvars:st${o} = [${f(r)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const e=t.color;return void 0!==e&&(n+=`\n\tcolor3f[] primvars:displayColor = [${p(e,e.count)}] (\n\t\tinterpolation = "vertex"\n\t\t)`),n}(n)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}(t);return`\ndef "Geometry"\n{\n${n}\n}\n`}(n);e[a]=function(t){let n='#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n';return n+=t,(0,r._u)(n)}(t)}o.uuid in c||(c[o.uuid]=o),i+=function(t,n,e){const o="Object_"+t.id,r=l(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),`def Xform "${o}" (\n\tprepend references = @./geometries/Geometry_${n.id}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${r}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\trel material:binding = </Materials/Material_${e.id}>\n}\n\n`}(t,n,o)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",t)}else t.isCamera&&(i+=function(t){const n=t.name?t.name:"Camera_"+t.id,e=l(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),t.isOrthographicCamera?`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(u)}, ${t.far.toPrecision(u)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(u)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(u)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`:`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(u)}, ${t.far.toPrecision(u)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(u)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(u)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(u)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(u)}\n\t\t}\n\t\n\t`}(t))})),i+="\n\t\t}\n\t}\n}\n\n",i+=function(t,n,e=!1){const o=[];for(const r in t){const a=t[r];o.push(m(a,n,e))}return`def "Materials"\n{\n${o.join("")}\n}\n\n`}(c,d,n.quickLookCompatible),e[o]=(0,r._u)(i),i=null;for(const t in d){let o=d[t];!0===o.isCompressedTexture&&(o=(0,a.m)(o));const r=s(o.image,o.flipY,n.maxTextureSize),i=await new Promise((t=>r.toBlob(t,"image/png",1)));e[`textures/Texture_${t}.png`]=new Uint8Array(await i.arrayBuffer())}let h=0;for(const t in e){const n=e[t];h+=34+t.length;const o=63&h;if(4!==o){const r=new Uint8Array(64-o);e[t]=[n,{extra:{12345:r}}]}h=n.length}return(0,r.L)(e,{level:0})}}function s(t,n,e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const o=e/Math.max(t.width,t.height),r=document.createElement("canvas");r.width=t.width*Math.min(1,o),r.height=t.height*Math.min(1,o);const a=r.getContext("2d");return!0===n&&(a.translate(0,r.height),a.scale(1,-1)),a.drawImage(t,0,0,r.width,r.height),r}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const u=7;function l(t){const n=t.elements;return`( ${c(n,0)}, ${c(n,4)}, ${c(n,8)}, ${c(n,12)} )`}function c(t,n){return`(${t[n+0]}, ${t[n+1]}, ${t[n+2]}, ${t[n+3]})`}function p(t,n){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(n).fill("(0, 0, 0)").join(", ");const e=[];for(let n=0;n<t.count;n++){const o=t.getX(n),r=t.getY(n),a=t.getZ(n);e.push(`(${o.toPrecision(u)}, ${r.toPrecision(u)}, ${a.toPrecision(u)})`)}return e.join(", ")}function f(t){const n=[];for(let e=0;e<t.count;e++){const o=t.getX(e),r=t.getY(e);n.push(`(${o.toPrecision(u)}, ${1-r.toPrecision(u)})`)}return n.join(", ")}function m(t,n,e=!1){const r="\t\t\t",a=[],i=[];function s(r,a,i){const s=r.source.id+"_"+r.flipY;n[s]=r;const l=r.channel>0?"st"+r.channel:"st",c={1e3:"repeat",1001:"clamp",1002:"mirror"},p=r.repeat.clone(),f=r.offset.clone(),m=r.rotation,d=Math.sin(m),$=Math.cos(m);return f.y=1-f.y-p.y,e?(f.x=f.x/p.x,f.y=f.y/p.y,f.x+=d/p.x,f.y+=$-1):(f.x+=d*p.x,f.y+=(1-$)*p.y),`\n\t\tdef Shader "PrimvarReader_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdPrimvarReader_float2"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = "${l}"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Transform2d_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdTransform2d"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${a}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(m*(180/Math.PI)).toFixed(u)}\n\t\t\tfloat2 inputs:scale = ${h(p)}\n\t\t\tfloat2 inputs:translation = ${h(f)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Texture_${r.id}_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdUVTexture"\n\t\t\tasset inputs:file = @textures/Texture_${s}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${a}.outputs:result>\n\t\t\t${void 0!==i?"float4 inputs:scale = "+function(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}(i):""}\n\t\t\ttoken inputs:sourceColorSpace = "${r.colorSpace===o.NoColorSpace?"raw":"sRGB"}"\n\t\t\ttoken inputs:wrapS = "${c[r.wrapS]}"\n\t\t\ttoken inputs:wrapT = "${c[r.wrapT]}"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${t.transparent||t.alphaTest>0?"float outputs:a":""}\n\t\t}`}return t.side===o.DoubleSide&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t),null!==t.map?(a.push(`${r}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?a.push(`${r}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(a.push(`${r}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),a.push(`${r}float inputs:opacityThreshold = ${t.alphaTest}`)),i.push(s(t.map,"diffuse",t.color))):a.push(`${r}color3f inputs:diffuseColor = ${d(t.color)}`),null!==t.emissiveMap?(a.push(`${r}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),i.push(s(t.emissiveMap,"emissive"))):t.emissive.getHex()>0&&a.push(`${r}color3f inputs:emissiveColor = ${d(t.emissive)}`),null!==t.normalMap&&(a.push(`${r}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),i.push(s(t.normalMap,"normal"))),null!==t.aoMap&&(a.push(`${r}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),i.push(s(t.aoMap,"occlusion"))),null!==t.roughnessMap&&1===t.roughness?(a.push(`${r}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),i.push(s(t.roughnessMap,"roughness"))):a.push(`${r}float inputs:roughness = ${t.roughness}`),null!==t.metalnessMap&&1===t.metalness?(a.push(`${r}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),i.push(s(t.metalnessMap,"metallic"))):a.push(`${r}float inputs:metallic = ${t.metalness}`),null!==t.alphaMap?(a.push(`${r}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),a.push(`${r}float inputs:opacityThreshold = 0.0001`),i.push(s(t.alphaMap,"opacity"))):a.push(`${r}float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial&&(a.push(`${r}float inputs:clearcoat = ${t.clearcoat}`),a.push(`${r}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),a.push(`${r}float inputs:ior = ${t.ior}`)),`\n\tdef Material "Material_${t.id}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${a.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n\n${i.join("\n")}\n\n\t}\n`}function d(t){return`(${t.r}, ${t.g}, ${t.b})`}function h(t){return`(${t.x}, ${t.y})`}},4655:(t,n,e)=>{e.d(n,{m:()=>u});var o=e(9451);let r,a,i,s;function u(t,n=1/0,e=null){a||(a=new o.PlaneGeometry(2,2,1,1)),i||(i=new o.ShaderMaterial({uniforms:{blitTexture:new o.Uniform(t)},vertexShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main(){\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = vec4(position.xy * 1.0,0.,.999999);\n\t\t\t}",fragmentShader:"\n\t\t\tuniform sampler2D blitTexture; \n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main(){ \n\t\t\t\tgl_FragColor = vec4(vUv.xy, 0, 1);\n\t\t\t\t\n\t\t\t\t#ifdef IS_SRGB\n\t\t\t\tgl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n\t\t\t\t#else\n\t\t\t\tgl_FragColor = texture2D( blitTexture, vUv);\n\t\t\t\t#endif\n\t\t\t}"})),i.uniforms.blitTexture.value=t,i.defines.IS_SRGB=t.colorSpace==o.SRGBColorSpace,i.needsUpdate=!0,s||(s=new o.Mesh(a,i),s.frustumCulled=!1);const u=new o.PerspectiveCamera,l=new o.Scene;l.add(s),null===e&&(e=r=new o.WebGLRenderer({antialias:!1}));const c=Math.min(t.image.width,n),p=Math.min(t.image.height,n);e.setSize(c,p),e.clear(),e.render(l,u);const f=document.createElement("canvas"),m=f.getContext("2d");f.width=c,f.height=p,m.drawImage(e.domElement,0,0,c,p);const d=new o.CanvasTexture(f);return d.minFilter=t.minFilter,d.magFilter=t.magFilter,d.wrapS=t.wrapS,d.wrapT=t.wrapT,d.name=t.name,r&&(r.forceContextLoss(),r.dispose(),r=null),d}}}]);