"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[306],{6306:(e,t,s)=>{s.d(t,{GLTFExporter:()=>a});var n=s(9451),r=s(4655);const i={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class a{constructor(){this.pluginCallbacks=[],this.register((function(e){return new b(e)})),this.register((function(e){return new v(e)})),this.register((function(e){return new C(e)})),this.register((function(e){return new S(e)})),this.register((function(e){return new E(e)})),this.register((function(e){return new L(e)})),this.register((function(e){return new I(e)})),this.register((function(e){return new A(e)})),this.register((function(e){return new R(e)})),this.register((function(e){return new U(e)})),this.register((function(e){return new F(e)})),this.register((function(e){return new N(e)})),this.register((function(e){return new k(e)})),this.register((function(e){return new z(e)}))}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){const r=new w,i=[];for(let e=0,t=this.pluginCallbacks.length;e<t;e++)i.push(this.pluginCallbacks[e](r));r.setPlugins(i),r.write(e,t,n).catch(s)}parseAsync(e,t){const s=this;return new Promise((function(n,r){s.parse(e,n,r,t)}))}}const o=5120,c=5121,l=5122,u=5123,h=34962,p="KHR_mesh_quantization",m={};m[n.NearestFilter]=9728,m[n.NearestMipmapNearestFilter]=9984,m[n.NearestMipmapLinearFilter]=9986,m[n.LinearFilter]=9729,m[n.LinearMipmapNearestFilter]=9985,m[n.LinearMipmapLinearFilter]=9987,m[n.ClampToEdgeWrapping]=33071,m[n.RepeatWrapping]=10497,m[n.MirroredRepeatWrapping]=33648;const f={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},d=new n.Color;function g(e,t){return e.length===t.length&&e.every((function(e,s){return e===t[s]}))}function x(e){return 4*Math.ceil(e/4)}function y(e,t=0){const s=x(e.byteLength);if(s!==e.byteLength){const n=new Uint8Array(s);if(n.set(new Uint8Array(e)),0!==t)for(let r=e.byteLength;r<s;r++)n[r]=t;return n.buffer}return e}function T(){return"undefined"==typeof document&&"undefined"!=typeof OffscreenCanvas?new OffscreenCanvas(1,1):document.createElement("canvas")}function M(e,t){if(void 0!==e.toBlob)return new Promise((s=>e.toBlob(s,t)));let s;return"image/jpeg"===t?s=.92:"image/webp"===t&&(s=.8),e.convertToBlob({type:t,quality:s})}class w{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+n.REVISION}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,s={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},s),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const n=this,r=n.buffers,i=n.json;s=n.options;const a=n.extensionsUsed,o=n.extensionsRequired,c=new Blob(r,{type:"application/octet-stream"}),l=Object.keys(a),u=Object.keys(o);if(l.length>0&&(i.extensionsUsed=l),u.length>0&&(i.extensionsRequired=u),i.buffers&&i.buffers.length>0&&(i.buffers[0].byteLength=c.size),!0===s.binary){const e=new FileReader;e.readAsArrayBuffer(c),e.onloadend=function(){const s=y(e.result),n=new DataView(new ArrayBuffer(8));n.setUint32(0,s.byteLength,!0),n.setUint32(4,5130562,!0);const r=y((a=JSON.stringify(i),(new TextEncoder).encode(a).buffer),32);var a;const o=new DataView(new ArrayBuffer(8));o.setUint32(0,r.byteLength,!0),o.setUint32(4,1313821514,!0);const c=new ArrayBuffer(12),l=new DataView(c);l.setUint32(0,1179937895,!0),l.setUint32(4,2,!0);const u=12+o.byteLength+r.byteLength+n.byteLength+s.byteLength;l.setUint32(8,u,!0);const h=new Blob([c,o,r,n,s],{type:"application/octet-stream"}),p=new FileReader;p.readAsArrayBuffer(h),p.onloadend=function(){t(p.result)}}}else if(i.buffers&&i.buffers.length>0){const e=new FileReader;e.readAsDataURL(c),e.onloadend=function(){const s=e.result;i.buffers[0].uri=s,t(i)}}else t(i)}serializeUserData(e,t){if(0===Object.keys(e.userData).length)return;const s=this.options,n=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(s.includeCustomExtensions&&r.gltfExtensions){void 0===t.extensions&&(t.extensions={});for(const e in r.gltfExtensions)t.extensions[e]=r.gltfExtensions[e],n[e]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(t){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+t.message)}}getUID(e,t=!1){if(!1===this.uids.has(e)){const t=new Map;t.set(!0,this.uid++),t.set(!1,this.uid++),this.uids.set(e,t)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const t=new n.Vector3;for(let s=0,n=e.count;s<n;s++)if(Math.abs(t.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const s=e.clone(),r=new n.Vector3;for(let e=0,t=s.count;e<t;e++)r.fromBufferAttribute(s,e),0===r.x&&0===r.y&&0===r.z?r.setX(1):r.normalize(),s.setXYZ(e,r.x,r.y,r.z);return t.attributesNormalized.set(e,s),s}applyTextureTransform(e,t){let s=!1;const n={};0===t.offset.x&&0===t.offset.y||(n.offset=t.offset.toArray(),s=!0),0!==t.rotation&&(n.rotation=t.rotation,s=!0),1===t.repeat.x&&1===t.repeat.y||(n.scale=t.repeat.toArray(),s=!0),s&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=n,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function s(e){return e.colorSpace===n.SRGBColorSpace?function(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}:function(e){return e}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),e instanceof n.CompressedTexture&&(e=(0,r.m)(e)),t instanceof n.CompressedTexture&&(t=(0,r.m)(t));const i=e?e.image:null,a=t?t.image:null,o=Math.max(i?i.width:0,a?a.width:0),c=Math.max(i?i.height:0,a?a.height:0),l=T();l.width=o,l.height=c;const u=l.getContext("2d");u.fillStyle="#00ffff",u.fillRect(0,0,o,c);const h=u.getImageData(0,0,o,c);if(i){u.drawImage(i,0,0,o,c);const t=s(e),n=u.getImageData(0,0,o,c).data;for(let e=2;e<n.length;e+=4)h.data[e]=256*t(n[e]/256)}if(a){u.drawImage(a,0,0,o,c);const e=s(t),n=u.getImageData(0,0,o,c).data;for(let t=1;t<n.length;t+=4)h.data[t]=256*e(n[t]/256)}u.putImageData(h,0,0);const p=(e||t).clone();return p.source=new n.Source(l),p.colorSpace=n.NoColorSpace,p.channel=(e||t).channel,e&&t&&e.channel!==t.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),p}processBuffer(e){const t=this.json,s=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),s.push(e),0}processBufferView(e,t,s,r,i){const a=this.json;let p;switch(a.bufferViews||(a.bufferViews=[]),t){case o:case c:p=1;break;case l:case u:p=2;break;default:p=4}let m=e.itemSize*p;i===h&&(m=4*Math.ceil(m/4));const f=x(r*m),d=new DataView(new ArrayBuffer(f));let g=0;for(let i=s;i<s+r;i++){for(let s=0;s<e.itemSize;s++){let r;e.itemSize>4?r=e.array[i*e.itemSize+s]:(0===s?r=e.getX(i):1===s?r=e.getY(i):2===s?r=e.getZ(i):3===s&&(r=e.getW(i)),!0===e.normalized&&(r=n.MathUtils.normalize(r,e.array))),5126===t?d.setFloat32(g,r,!0):5124===t?d.setInt32(g,r,!0):5125===t?d.setUint32(g,r,!0):t===l?d.setInt16(g,r,!0):t===u?d.setUint16(g,r,!0):t===o?d.setInt8(g,r):t===c&&d.setUint8(g,r),g+=p}g%m!=0&&(g+=m-g%m)}const y={buffer:this.processBuffer(d.buffer),byteOffset:this.byteOffset,byteLength:f};return void 0!==i&&(y.target=i),i===h&&(y.byteStride=m),this.byteOffset+=f,a.bufferViews.push(y),{id:a.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,s=t.json;return s.bufferViews||(s.bufferViews=[]),new Promise((function(n){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const e=y(r.result),i={buffer:t.processBuffer(e),byteOffset:t.byteOffset,byteLength:e.byteLength};t.byteOffset+=e.byteLength,n(s.bufferViews.push(i)-1)}}))}processAccessor(e,t,s,r){const i=this.json;let a;if(e.array.constructor===Float32Array)a=5126;else if(e.array.constructor===Int32Array)a=5124;else if(e.array.constructor===Uint32Array)a=5125;else if(e.array.constructor===Int16Array)a=l;else if(e.array.constructor===Uint16Array)a=u;else if(e.array.constructor===Int8Array)a=o;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);a=c}if(void 0===s&&(s=0),void 0!==r&&r!==1/0||(r=e.count),0===r)return null;const p=function(e,t,s){const r={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let i=t;i<t+s;i++)for(let t=0;t<e.itemSize;t++){let s;e.itemSize>4?s=e.array[i*e.itemSize+t]:(0===t?s=e.getX(i):1===t?s=e.getY(i):2===t?s=e.getZ(i):3===t&&(s=e.getW(i)),!0===e.normalized&&(s=n.MathUtils.normalize(s,e.array))),r.min[t]=Math.min(r.min[t],s),r.max[t]=Math.max(r.max[t],s)}return r}(e,s,r);let m;void 0!==t&&(m=e===t.index?34963:h);const f=this.processBufferView(e,a,s,r,m),d={bufferView:f.id,byteOffset:f.byteOffset,componentType:a,count:r,max:p.max,min:p.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"}[e.itemSize]};return!0===e.normalized&&(d.normalized=!0),i.accessors||(i.accessors=[]),i.accessors.push(d)-1}processImage(e,t,s,r="image/png"){if(null!==e){const i=this,a=i.cache,o=i.json,c=i.options,l=i.pending;a.images.has(e)||a.images.set(e,{});const u=a.images.get(e),h=r+":flipY/"+s.toString();if(void 0!==u[h])return u[h];o.images||(o.images=[]);const p={mimeType:r},m=T();m.width=Math.min(e.width,c.maxTextureSize),m.height=Math.min(e.height,c.maxTextureSize);const f=m.getContext("2d");if(!0===s&&(f.translate(0,m.height),f.scale(1,-1)),void 0!==e.data){t!==n.RGBAFormat&&console.error("GLTFExporter: Only RGBAFormat is supported.",t),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const s=new Uint8ClampedArray(e.height*e.width*4);for(let t=0;t<s.length;t+=4)s[t+0]=e.data[t+0],s[t+1]=e.data[t+1],s[t+2]=e.data[t+2],s[t+3]=e.data[t+3];f.putImageData(new ImageData(s,e.width,e.height),0,0)}else{if(!("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas))throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");f.drawImage(e,0,0,m.width,m.height)}!0===c.binary?l.push(M(m,r).then((e=>i.processBufferViewImage(e))).then((e=>{p.bufferView=e}))):void 0!==m.toDataURL?p.uri=m.toDataURL(r):l.push(M(m,r).then((e=>(new FileReader).readAsDataURL(e))).then((e=>{p.uri=e})));const d=o.images.push(p)-1;return u[h]=d,d}throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const s={magFilter:m[e.magFilter],minFilter:m[e.minFilter],wrapS:m[e.wrapS],wrapT:m[e.wrapT]};return t.samplers.push(s)-1}processTexture(e){const t=this.options,s=this.cache,i=this.json;if(s.textures.has(e))return s.textures.get(e);i.textures||(i.textures=[]),e instanceof n.CompressedTexture&&(e=(0,r.m)(e,t.maxTextureSize));let a=e.userData.mimeType;"image/webp"===a&&(a="image/png");const o={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,a)};e.name&&(o.name=e.name),this._invokeAll((function(t){t.writeTexture&&t.writeTexture(e,o)}));const c=i.textures.push(o)-1;return s.textures.set(e,c),c}processMaterial(e){const t=this.cache,s=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;s.materials||(s.materials=[]);const r={pbrMetallicRoughness:{}};!0!==e.isMeshStandardMaterial&&!0!==e.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const i=e.color.toArray().concat([e.opacity]);if(g(i,[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=i),e.isMeshStandardMaterial?(r.pbrMetallicRoughness.metallicFactor=e.metalness,r.pbrMetallicRoughness.roughnessFactor=e.roughness):(r.pbrMetallicRoughness.metallicFactor=.5,r.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const t=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),s={index:this.processTexture(t),channel:t.channel};this.applyTextureTransform(s,t),r.pbrMetallicRoughness.metallicRoughnessTexture=s}if(e.map){const t={index:this.processTexture(e.map),texCoord:e.map.channel};this.applyTextureTransform(t,e.map),r.pbrMetallicRoughness.baseColorTexture=t}if(e.emissive){const t=e.emissive;if(Math.max(t.r,t.g,t.b)>0&&(r.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const t={index:this.processTexture(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(t,e.emissiveMap),r.emissiveTexture=t}}if(e.normalMap){const t={index:this.processTexture(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&1!==e.normalScale.x&&(t.scale=e.normalScale.x),this.applyTextureTransform(t,e.normalMap),r.normalTexture=t}if(e.aoMap){const t={index:this.processTexture(e.aoMap),texCoord:e.aoMap.channel};1!==e.aoMapIntensity&&(t.strength=e.aoMapIntensity),this.applyTextureTransform(t,e.aoMap),r.occlusionTexture=t}e.transparent?r.alphaMode="BLEND":e.alphaTest>0&&(r.alphaMode="MASK",r.alphaCutoff=e.alphaTest),e.side===n.DoubleSide&&(r.doubleSided=!0),""!==e.name&&(r.name=e.name),this.serializeUserData(e,r),this._invokeAll((function(t){t.writeMaterial&&t.writeMaterial(e,r)}));const a=s.materials.push(r)-1;return t.materials.set(e,a),a}processMesh(e){const t=this.cache,s=this.json,r=[e.geometry.uuid];if(Array.isArray(e.material))for(let t=0,s=e.material.length;t<s;t++)r.push(e.material[t].uuid);else r.push(e.material.uuid);const i=r.join(":");if(t.meshes.has(i))return t.meshes.get(i);const a=e.geometry;let o;o=e.isLineSegments?1:e.isLineLoop?2:e.isLine?3:e.isPoints?0:e.material.wireframe?1:4;const c={},l={},u=[],h=[],p={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},m=a.getAttribute("normal");void 0===m||this.isNormalizedNormalAttribute(m)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),a.setAttribute("normal",this.createNormalizedNormalAttribute(m)));let f=null;for(let e in a.attributes){if("morph"===e.slice(0,5))continue;const s=a.attributes[e];if(e=p[e]||e.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e)||(e="_"+e),t.attributes.has(this.getUID(s))){l[e]=t.attributes.get(this.getUID(s));continue}f=null;const r=s.array;"JOINTS_0"!==e||r instanceof Uint16Array||r instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),f=new n.BufferAttribute(new Uint16Array(r),s.itemSize,s.normalized));const i=this.processAccessor(f||s,a);null!==i&&(e.startsWith("_")||this.detectMeshQuantization(e,s),l[e]=i,t.attributes.set(this.getUID(s),i))}if(void 0!==m&&a.setAttribute("normal",m),0===Object.keys(l).length)return null;if(void 0!==e.morphTargetInfluences&&e.morphTargetInfluences.length>0){const s=[],n=[],r={};if(void 0!==e.morphTargetDictionary)for(const t in e.morphTargetDictionary)r[e.morphTargetDictionary[t]]=t;for(let i=0;i<e.morphTargetInfluences.length;++i){const o={};let c=!1;for(const e in a.morphAttributes){if("position"!==e&&"normal"!==e){c||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),c=!0);continue}const s=a.morphAttributes[e][i],n=e.toUpperCase(),r=a.attributes[e];if(t.attributes.has(this.getUID(s,!0))){o[n]=t.attributes.get(this.getUID(s,!0));continue}const l=s.clone();if(!a.morphTargetsRelative)for(let e=0,t=s.count;e<t;e++)for(let t=0;t<s.itemSize;t++)0===t&&l.setX(e,s.getX(e)-r.getX(e)),1===t&&l.setY(e,s.getY(e)-r.getY(e)),2===t&&l.setZ(e,s.getZ(e)-r.getZ(e)),3===t&&l.setW(e,s.getW(e)-r.getW(e));o[n]=this.processAccessor(l,a),t.attributes.set(this.getUID(r,!0),o[n])}h.push(o),s.push(e.morphTargetInfluences[i]),void 0!==e.morphTargetDictionary&&n.push(r[i])}c.weights=s,n.length>0&&(c.extras={},c.extras.targetNames=n)}const d=Array.isArray(e.material);if(d&&0===a.groups.length)return null;let g=!1;if(d&&null===a.index){const e=[];for(let t=0,s=a.attributes.position.count;t<s;t++)e[t]=t;a.setIndex(e),g=!0}const x=d?e.material:[e.material],y=d?a.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let e=0,s=y.length;e<s;e++){const s={mode:o,attributes:l};if(this.serializeUserData(a,s),h.length>0&&(s.targets=h),null!==a.index){let n=this.getUID(a.index);void 0===y[e].start&&void 0===y[e].count||(n+=":"+y[e].start+":"+y[e].count),t.attributes.has(n)?s.indices=t.attributes.get(n):(s.indices=this.processAccessor(a.index,a,y[e].start,y[e].count),t.attributes.set(n,s.indices)),null===s.indices&&delete s.indices}const n=this.processMaterial(x[y[e].materialIndex]);null!==n&&(s.material=n),u.push(s)}!0===g&&a.setIndex(null),c.primitives=u,s.meshes||(s.meshes=[]),this._invokeAll((function(t){t.writeMesh&&t.writeMesh(e,c)}));const T=s.meshes.push(c)-1;return t.meshes.set(i,T),T}detectMeshQuantization(e,t){if(this.extensionsUsed[p])return;let s;switch(t.array.constructor){case Int8Array:s="byte";break;case Uint8Array:s="unsigned byte";break;case Int16Array:s="short";break;case Uint16Array:s="unsigned short";break;default:return}t.normalized&&(s+=" normalized");const n=e.split("_",1)[0];i[n]&&i[n].includes(s)&&(this.extensionsUsed[p]=!0,this.extensionsRequired[p]=!0)}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const s=e.isOrthographicCamera,r={type:s?"orthographic":"perspective"};return s?r.orthographic={xmag:2*e.right,ymag:2*e.top,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:r.perspective={aspectRatio:e.aspect,yfov:n.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},""!==e.name&&(r.name=e.type),t.cameras.push(r)-1}processAnimation(e,t){const s=this.json,r=this.nodeMap;s.animations||(s.animations=[]);const i=(e=a.Utils.mergeMorphTargetTracks(e.clone(),t)).tracks,o=[],c=[];for(let e=0;e<i.length;++e){const s=i[e],a=n.PropertyBinding.parseTrackName(s.name);let l=n.PropertyBinding.findNode(t,a.nodeName);const u=f[a.propertyName];if("bones"===a.objectName&&(l=!0===l.isSkinnedMesh?l.skeleton.getBoneByName(a.objectIndex):void 0),!l||!u)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',s.name),null;const h=1;let p,m=s.values.length/s.times.length;u===f.morphTargetInfluences&&(m/=l.morphTargetInfluences.length),!0===s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(p="CUBICSPLINE",m/=3):p=s.getInterpolation()===n.InterpolateDiscrete?"STEP":"LINEAR",c.push({input:this.processAccessor(new n.BufferAttribute(s.times,h)),output:this.processAccessor(new n.BufferAttribute(s.values,m)),interpolation:p}),o.push({sampler:c.length-1,target:{node:r.get(l),path:u}})}return s.animations.push({name:e.name||"clip_"+s.animations.length,samplers:c,channels:o}),s.animations.length-1}processSkin(e){const t=this.json,s=this.nodeMap,r=t.nodes[s.get(e)],i=e.skeleton;if(void 0===i)return null;const a=e.skeleton.bones[0];if(void 0===a)return null;const o=[],c=new Float32Array(16*i.bones.length),l=new n.Matrix4;for(let t=0;t<i.bones.length;++t)o.push(s.get(i.bones[t])),l.copy(i.boneInverses[t]),l.multiply(e.bindMatrix).toArray(c,16*t);return void 0===t.skins&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new n.BufferAttribute(c,16)),joints:o,skeleton:s.get(a)}),r.skin=t.skins.length-1}processNode(e){const t=this.json,s=this.options,n=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(s.trs){const t=e.quaternion.toArray(),s=e.position.toArray(),n=e.scale.toArray();g(t,[0,0,0,1])||(r.rotation=t),g(s,[0,0,0])||(r.translation=s),g(n,[1,1,1])||(r.scale=n)}else e.matrixAutoUpdate&&e.updateMatrix(),!1===g(e.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])&&(r.matrix=e.matrix.elements);if(""!==e.name&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const t=this.processMesh(e);null!==t&&(r.mesh=t)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const t=[];for(let n=0,r=e.children.length;n<r;n++){const r=e.children[n];if(r.visible||!1===s.onlyVisible){const e=this.processNode(r);null!==e&&t.push(e)}}t.length>0&&(r.children=t)}this._invokeAll((function(t){t.writeNode&&t.writeNode(e,r)}));const i=t.nodes.push(r)-1;return n.set(e,i),i}processScene(e){const t=this.json,s=this.options;t.scenes||(t.scenes=[],t.scene=0);const n={};""!==e.name&&(n.name=e.name),t.scenes.push(n);const r=[];for(let t=0,n=e.children.length;t<n;t++){const n=e.children[t];if(n.visible||!1===s.onlyVisible){const e=this.processNode(n);null!==e&&r.push(e)}}r.length>0&&(n.nodes=r),this.serializeUserData(e,n)}processObjects(e){const t=new n.Scene;t.name="AuxScene";for(let s=0;s<e.length;s++)t.children.push(e[s]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll((function(t){t.beforeParse&&t.beforeParse(e)}));const s=[];for(let t=0;t<e.length;t++)e[t]instanceof n.Scene?this.processScene(e[t]):s.push(e[t]);s.length>0&&this.processObjects(s);for(let e=0;e<this.skins.length;++e)this.processSkin(this.skins[e]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);this._invokeAll((function(t){t.afterParse&&t.afterParse(e)}))}_invokeAll(e){for(let t=0,s=this.plugins.length;t<s;t++)e(this.plugins[t])}}class b{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight)return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);const s=this.writer,n=s.json,r=s.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(1-e.penumbra)*e.angle,i.spot.outerConeAngle=e.angle),void 0!==e.decay&&2!==e.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(n.extensions=n.extensions||{},n.extensions[this.name]={lights:[]},r[this.name]=!0);const a=n.extensions[this.name].lights;a.push(i),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}class v{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class I{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.clearcoat)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const t={index:s.processTexture(e.clearcoatMap),texCoord:e.clearcoatMap.channel};s.applyTextureTransform(t,e.clearcoatMap),r.clearcoatTexture=t}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const t={index:s.processTexture(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};s.applyTextureTransform(t,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=t}if(e.clearcoatNormalMap){const t={index:s.processTexture(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};1!==e.clearcoatNormalScale.x&&(t.scale=e.clearcoatNormalScale.x),s.applyTextureTransform(t,e.clearcoatNormalMap),r.clearcoatNormalTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class A{constructor(e){this.writer=e,this.name="KHR_materials_dispersion"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.dispersion)return;const s=this.writer.extensionsUsed,n={};n.dispersion=e.dispersion,t.extensions=t.extensions||{},t.extensions[this.name]=n,s[this.name]=!0}}class R{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.iridescence)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const t={index:s.processTexture(e.iridescenceMap),texCoord:e.iridescenceMap.channel};s.applyTextureTransform(t,e.iridescenceMap),r.iridescenceTexture=t}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const t={index:s.processTexture(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};s.applyTextureTransform(t,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class C{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.transmission)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const t={index:s.processTexture(e.transmissionMap),texCoord:e.transmissionMap.channel};s.applyTextureTransform(t,e.transmissionMap),r.transmissionTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class S{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0===e.transmission)return;const s=this.writer,n=s.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const t={index:s.processTexture(e.thicknessMap),texCoord:e.thicknessMap.channel};s.applyTextureTransform(t,e.thicknessMap),r.thicknessTexture=t}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class E{constructor(e){this.writer=e,this.name="KHR_materials_ior"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||1.5===e.ior)return;const s=this.writer.extensionsUsed,n={};n.ior=e.ior,t.extensions=t.extensions||{},t.extensions[this.name]=n,s[this.name]=!0}}class L{constructor(e){this.writer=e,this.name="KHR_materials_specular"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||1===e.specularIntensity&&e.specularColor.equals(d)&&!e.specularIntensityMap&&!e.specularColorMap)return;const s=this.writer,n=s.extensionsUsed,r={};if(e.specularIntensityMap){const t={index:s.processTexture(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};s.applyTextureTransform(t,e.specularIntensityMap),r.specularTexture=t}if(e.specularColorMap){const t={index:s.processTexture(e.specularColorMap),texCoord:e.specularColorMap.channel};s.applyTextureTransform(t,e.specularColorMap),r.specularColorTexture=t}r.specularFactor=e.specularIntensity,r.specularColorFactor=e.specularColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class U{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0==e.sheen)return;const s=this.writer,n=s.extensionsUsed,r={};if(e.sheenRoughnessMap){const t={index:s.processTexture(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};s.applyTextureTransform(t,e.sheenRoughnessMap),r.sheenRoughnessTexture=t}if(e.sheenColorMap){const t={index:s.processTexture(e.sheenColorMap),texCoord:e.sheenColorMap.channel};s.applyTextureTransform(t,e.sheenColorMap),r.sheenColorTexture=t}r.sheenRoughnessFactor=e.sheenRoughness,r.sheenColorFactor=e.sheenColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class F{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||0==e.anisotropy)return;const s=this.writer,n=s.extensionsUsed,r={};if(e.anisotropyMap){const t={index:s.processTexture(e.anisotropyMap)};s.applyTextureTransform(t,e.anisotropyMap),r.anisotropyTexture=t}r.anisotropyStrength=e.anisotropy,r.anisotropyRotation=e.anisotropyRotation,t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class N{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}writeMaterial(e,t){if(!e.isMeshStandardMaterial||1===e.emissiveIntensity)return;const s=this.writer.extensionsUsed,n={};n.emissiveStrength=e.emissiveIntensity,t.extensions=t.extensions||{},t.extensions[this.name]=n,s[this.name]=!0}}class k{constructor(e){this.writer=e,this.name="EXT_materials_bump"}writeMaterial(e,t){if(!e.isMeshStandardMaterial||1===e.bumpScale&&!e.bumpMap)return;const s=this.writer,n=s.extensionsUsed,r={};if(e.bumpMap){const t={index:s.processTexture(e.bumpMap),texCoord:e.bumpMap.channel};s.applyTextureTransform(t,e.bumpMap),r.bumpTexture=t}r.bumpFactor=e.bumpScale,t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}}class z{constructor(e){this.writer=e,this.name="EXT_mesh_gpu_instancing"}writeNode(e,t){if(!e.isInstancedMesh)return;const s=this.writer,r=e,i=new Float32Array(3*r.count),a=new Float32Array(4*r.count),o=new Float32Array(3*r.count),c=new n.Matrix4,l=new n.Vector3,u=new n.Quaternion,h=new n.Vector3;for(let e=0;e<r.count;e++)r.getMatrixAt(e,c),c.decompose(l,u,h),l.toArray(i,3*e),u.toArray(a,4*e),h.toArray(o,3*e);const p={TRANSLATION:s.processAccessor(new n.BufferAttribute(i,3)),ROTATION:s.processAccessor(new n.BufferAttribute(a,4)),SCALE:s.processAccessor(new n.BufferAttribute(o,3))};r.instanceColor&&(p._COLOR_0=s.processAccessor(r.instanceColor)),t.extensions=t.extensions||{},t.extensions[this.name]={attributes:p},s.extensionsUsed[this.name]=!0,s.extensionsRequired[this.name]=!0}}a.Utils={insertKeyframe:function(e,t){const s=.001,n=e.getValueSize(),r=new e.TimeBufferType(e.times.length+1),i=new e.ValueBufferType(e.values.length+n),a=e.createInterpolant(new e.ValueBufferType(n));let o;if(0===e.times.length){r[0]=t;for(let e=0;e<n;e++)i[e]=0;o=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<s)return 0;r[0]=t,r.set(e.times,1),i.set(a.evaluate(t),0),i.set(e.values,n),o=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<s)return e.times.length-1;r[r.length-1]=t,r.set(e.times,0),i.set(e.values,0),i.set(a.evaluate(t),e.values.length),o=r.length-1}else for(let c=0;c<e.times.length;c++){if(Math.abs(e.times[c]-t)<s)return c;if(e.times[c]<t&&e.times[c+1]>t){r.set(e.times.slice(0,c+1),0),r[c+1]=t,r.set(e.times.slice(c+1),c+2),i.set(e.values.slice(0,(c+1)*n),0),i.set(a.evaluate(t),(c+1)*n),i.set(e.values.slice((c+1)*n),(c+2)*n),o=c+1;break}}return e.times=r,e.values=i,o},mergeMorphTargetTracks:function(e,t){const s=[],r={},i=e.tracks;for(let e=0;e<i.length;++e){let a=i[e];const o=n.PropertyBinding.parseTrackName(a.name),c=n.PropertyBinding.findNode(t,o.nodeName);if("morphTargetInfluences"!==o.propertyName||void 0===o.propertyIndex){s.push(a);continue}if(a.createInterpolant!==a.InterpolantFactoryMethodDiscrete&&a.createInterpolant!==a.InterpolantFactoryMethodLinear){if(a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),a=a.clone(),a.setInterpolation(n.InterpolateLinear)}const l=c.morphTargetInfluences.length,u=c.morphTargetDictionary[o.propertyIndex];if(void 0===u)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let h;if(void 0===r[c.uuid]){h=a.clone();const e=new h.ValueBufferType(l*h.times.length);for(let t=0;t<h.times.length;t++)e[t*l+u]=h.values[t];h.name=(o.nodeName||"")+".morphTargetInfluences",h.values=e,r[c.uuid]=h,s.push(h);continue}const p=a.createInterpolant(new a.ValueBufferType(1));h=r[c.uuid];for(let e=0;e<h.times.length;e++)h.values[e*l+u]=p.evaluate(h.times[e]);for(let e=0;e<a.times.length;e++){const t=this.insertKeyframe(h,a.times[e]);h.values[t*l+u]=a.values[e]}}return e.tracks=s,e}}},4655:(e,t,s)=>{s.d(t,{m:()=>c});var n=s(9451);let r,i,a,o;function c(e,t=1/0,s=null){i||(i=new n.PlaneGeometry(2,2,1,1)),a||(a=new n.ShaderMaterial({uniforms:{blitTexture:new n.Uniform(e)},vertexShader:"\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main(){\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = vec4(position.xy * 1.0,0.,.999999);\n\t\t\t}",fragmentShader:"\n\t\t\tuniform sampler2D blitTexture; \n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main(){ \n\t\t\t\tgl_FragColor = vec4(vUv.xy, 0, 1);\n\t\t\t\t\n\t\t\t\t#ifdef IS_SRGB\n\t\t\t\tgl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n\t\t\t\t#else\n\t\t\t\tgl_FragColor = texture2D( blitTexture, vUv);\n\t\t\t\t#endif\n\t\t\t}"})),a.uniforms.blitTexture.value=e,a.defines.IS_SRGB=e.colorSpace==n.SRGBColorSpace,a.needsUpdate=!0,o||(o=new n.Mesh(i,a),o.frustumCulled=!1);const c=new n.PerspectiveCamera,l=new n.Scene;l.add(o),null===s&&(s=r=new n.WebGLRenderer({antialias:!1}));const u=Math.min(e.image.width,t),h=Math.min(e.image.height,t);s.setSize(u,h),s.clear(),s.render(l,c);const p=document.createElement("canvas"),m=p.getContext("2d");p.width=u,p.height=h,m.drawImage(s.domElement,0,0,u,h);const f=new n.CanvasTexture(p);return f.minFilter=e.minFilter,f.magFilter=e.magFilter,f.wrapS=e.wrapS,f.wrapT=e.wrapT,f.name=e.name,r&&(r.forceContextLoss(),r.dispose(),r=null),f}}}]);