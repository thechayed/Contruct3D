"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[946],{5946:(e,t,i)=>{i.d(t,{PCDLoader:()=>s});var n=i(9451);class s extends n.Loader{constructor(e){super(e),this.littleEndian=!0}load(e,t,i,s){const r=this,o=new n.FileLoader(r.manager);o.setPath(r.path),o.setResponseType("arraybuffer"),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,(function(i){try{t(r.parse(i))}catch(t){s?s(t):console.error(t),r.manager.itemError(e)}}),i,s)}parse(e){const t=(new TextDecoder).decode(e),i=function(e){const t={},i=e.search(/[\r\n]DATA\s(\S*)\s/i),n=/[\r\n]DATA\s(\S*)\s/i.exec(e.slice(i-1));if(t.data=n[1],t.headerLen=n[0].length+i,t.str=e.slice(0,t.headerLen),t.str=t.str.replace(/#.*/gi,""),t.version=/VERSION (.*)/i.exec(t.str),t.fields=/FIELDS (.*)/i.exec(t.str),t.size=/SIZE (.*)/i.exec(t.str),t.type=/TYPE (.*)/i.exec(t.str),t.count=/COUNT (.*)/i.exec(t.str),t.width=/WIDTH (.*)/i.exec(t.str),t.height=/HEIGHT (.*)/i.exec(t.str),t.viewpoint=/VIEWPOINT (.*)/i.exec(t.str),t.points=/POINTS (.*)/i.exec(t.str),null!==t.version&&(t.version=parseFloat(t.version[1])),t.fields=null!==t.fields?t.fields[1].split(" "):[],null!==t.type&&(t.type=t.type[1].split(" ")),null!==t.width&&(t.width=parseInt(t.width[1])),null!==t.height&&(t.height=parseInt(t.height[1])),null!==t.viewpoint&&(t.viewpoint=t.viewpoint[1]),null!==t.points&&(t.points=parseInt(t.points[1],10)),null===t.points&&(t.points=t.width*t.height),null!==t.size&&(t.size=t.size[1].split(" ").map((function(e){return parseInt(e,10)}))),null!==t.count)t.count=t.count[1].split(" ").map((function(e){return parseInt(e,10)}));else{t.count=[];for(let e=0,i=t.fields.length;e<i;e++)t.count.push(1)}t.offset={};let s=0;for(let e=0,i=t.fields.length;e<i;e++)"ascii"===t.data?t.offset[t.fields[e]]=e:(t.offset[t.fields[e]]=s,s+=t.size[e]*t.count[e]);return t.rowSize=s,t}(t),s=[],r=[],o=[],l=[],a=[],d=new n.Color;if("ascii"===i.data){const e=i.offset,n=t.slice(i.headerLen).split("\n");for(let t=0,h=n.length;t<h;t++){if(""===n[t])continue;const h=n[t].split(" ");if(void 0!==e.x&&(s.push(parseFloat(h[e.x])),s.push(parseFloat(h[e.y])),s.push(parseFloat(h[e.z]))),void 0!==e.rgb){const t=i.fields.findIndex((e=>"rgb"===e)),n=i.type[t],s=parseFloat(h[e.rgb]);let r=s;if("F"===n){const e=new Float32Array(1);e[0]=s,r=new Int32Array(e.buffer)[0]}const l=(r>>16&255)/255,a=(r>>8&255)/255,p=(255&r)/255;d.set(l,a,p).convertSRGBToLinear(),o.push(d.r,d.g,d.b)}void 0!==e.normal_x&&(r.push(parseFloat(h[e.normal_x])),r.push(parseFloat(h[e.normal_y])),r.push(parseFloat(h[e.normal_z]))),void 0!==e.intensity&&l.push(parseFloat(h[e.intensity])),void 0!==e.label&&a.push(parseInt(h[e.label]))}}if("binary_compressed"===i.data){const t=new Uint32Array(e.slice(i.headerLen,i.headerLen+8)),n=t[0],h=t[1],p=function(e,t){const i=e.length,n=new Uint8Array(t);let s,r,o,l=0,a=0;do{if(s=e[l++],s<32){if(s++,a+s>t)throw new Error("Output buffer is not large enough");if(l+s>i)throw new Error("Invalid compressed data");do{n[a++]=e[l++]}while(--s)}else{if(r=s>>5,o=a-((31&s)<<8)-1,l>=i)throw new Error("Invalid compressed data");if(7===r&&(r+=e[l++],l>=i))throw new Error("Invalid compressed data");if(o-=e[l++],a+r+2>t)throw new Error("Output buffer is not large enough");if(o<0)throw new Error("Invalid compressed data");if(o>=a)throw new Error("Invalid compressed data");do{n[a++]=n[o++]}while(2+--r)}}while(l<i);return n}(new Uint8Array(e,i.headerLen+8,n),h),f=new DataView(p.buffer),u=i.offset;for(let e=0;e<i.points;e++){if(void 0!==u.x){const t=i.fields.indexOf("x"),n=i.fields.indexOf("y"),r=i.fields.indexOf("z");s.push(f.getFloat32(i.points*u.x+i.size[t]*e,this.littleEndian)),s.push(f.getFloat32(i.points*u.y+i.size[n]*e,this.littleEndian)),s.push(f.getFloat32(i.points*u.z+i.size[r]*e,this.littleEndian))}if(void 0!==u.rgb){const t=i.fields.indexOf("rgb"),n=f.getUint8(i.points*u.rgb+i.size[t]*e+2)/255,s=f.getUint8(i.points*u.rgb+i.size[t]*e+1)/255,r=f.getUint8(i.points*u.rgb+i.size[t]*e+0)/255;d.set(n,s,r).convertSRGBToLinear(),o.push(d.r,d.g,d.b)}if(void 0!==u.normal_x){const t=i.fields.indexOf("normal_x"),n=i.fields.indexOf("normal_y"),s=i.fields.indexOf("normal_z");r.push(f.getFloat32(i.points*u.normal_x+i.size[t]*e,this.littleEndian)),r.push(f.getFloat32(i.points*u.normal_y+i.size[n]*e,this.littleEndian)),r.push(f.getFloat32(i.points*u.normal_z+i.size[s]*e,this.littleEndian))}if(void 0!==u.intensity){const t=i.fields.indexOf("intensity");l.push(f.getFloat32(i.points*u.intensity+i.size[t]*e,this.littleEndian))}if(void 0!==u.label){const t=i.fields.indexOf("label");a.push(f.getInt32(i.points*u.label+i.size[t]*e,this.littleEndian))}}}if("binary"===i.data){const t=new DataView(e,i.headerLen),n=i.offset;for(let e=0,h=0;e<i.points;e++,h+=i.rowSize){if(void 0!==n.x&&(s.push(t.getFloat32(h+n.x,this.littleEndian)),s.push(t.getFloat32(h+n.y,this.littleEndian)),s.push(t.getFloat32(h+n.z,this.littleEndian))),void 0!==n.rgb){const e=t.getUint8(h+n.rgb+2)/255,i=t.getUint8(h+n.rgb+1)/255,s=t.getUint8(h+n.rgb+0)/255;d.set(e,i,s).convertSRGBToLinear(),o.push(d.r,d.g,d.b)}void 0!==n.normal_x&&(r.push(t.getFloat32(h+n.normal_x,this.littleEndian)),r.push(t.getFloat32(h+n.normal_y,this.littleEndian)),r.push(t.getFloat32(h+n.normal_z,this.littleEndian))),void 0!==n.intensity&&l.push(t.getFloat32(h+n.intensity,this.littleEndian)),void 0!==n.label&&a.push(t.getInt32(h+n.label,this.littleEndian))}}const h=new n.BufferGeometry;s.length>0&&h.setAttribute("position",new n.Float32BufferAttribute(s,3)),r.length>0&&h.setAttribute("normal",new n.Float32BufferAttribute(r,3)),o.length>0&&h.setAttribute("color",new n.Float32BufferAttribute(o,3)),l.length>0&&h.setAttribute("intensity",new n.Float32BufferAttribute(l,1)),a.length>0&&h.setAttribute("label",new n.Int32BufferAttribute(a,1)),h.computeBoundingSphere();const p=new n.PointsMaterial({size:.005});return o.length>0&&(p.vertexColors=!0),new n.Points(h,p)}}}}]);